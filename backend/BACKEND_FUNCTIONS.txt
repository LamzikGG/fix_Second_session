================================================================================
ОПИСАНИЕ BACKEND ФУНКЦИЙ ПРОЕКТА CHAT MESSENGER
================================================================================

Файл: backend/app/main.py
База данных: SQLite (chat.db)
ORM: SQLAlchemy
Web Framework: FastAPI
WebSocket: для реального времени

================================================================================
1. АВТОРИЗАЦИЯ И ПОЛЬЗОВАТЕЛИ
================================================================================

POST /register
--------------
Описание: Регистрация нового пользователя
Параметры: UserCreate (username, password)
SQL операции:
  - Проверка существования пользователя: SELECT * FROM users WHERE username = ?
  - Создание: INSERT INTO users (username, hashed_password, is_active, created_at)
Возвращает: {user_id, username}

POST /login
-----------
Описание: Вход пользователя, получение JWT токена
Параметры: OAuth2PasswordRequestForm (username, password)
SQL операции:
  - Поиск пользователя: SELECT * FROM users WHERE username = ?
  - Проверка пароля через bcrypt
  - Обновление: UPDATE users SET is_active = True WHERE id = ?
Возвращает: {access_token, token_type, user_id, username}

GET /users/search?q=<query>
---------------------------
Описание: Поиск пользователей по логину
Параметры: q (строка поиска, минимум 2 символа)
SQL операции:
  - SELECT * FROM users WHERE username ILIKE '%query%' AND id != current_user.id AND is_active = True LIMIT 20
Возвращает: Список пользователей с полями {id, username, is_online, status}

GET /users
----------
Описание: Получить список всех активных пользователей (кроме текущего)
SQL операции:
  - SELECT * FROM users WHERE id != current_user.id AND is_active = True
Возвращает: Список пользователей {id, username, is_online, status}

================================================================================
2. СООБЩЕНИЯ (ЧАТЫ)
================================================================================

handle_chat_message(message_data, sender_id, db)
--------------------------------------------------
Описание: Обработка текстового сообщения через WebSocket
Параметры:
  - message_data: {receiver_id, content, is_group, group_id}
  - sender_id: ID отправителя
  - db: SQLAlchemy сессия
SQL операции:
  - INSERT INTO messages (sender_id, receiver_id, content, is_group, group_id, is_read, created_at)
  - Если получатель офлайн: INSERT INTO offline_messages (sender_id, receiver_id, content, delivered)
  - UPDATE messages SET is_read = False WHERE receiver_id = ? AND sender_id = ?
WebSocket: Отправка JSON {type: "message", message_id, sender_id, content, created_at, is_group, group_id} получателю

GET /messages/{user_id}
-----------------------
Описание: Получить историю личных сообщений 1-на-1 с пользователем
Параметры: user_id (ID собеседника)
SQL операции:
  - SELECT * FROM messages WHERE 
      ((sender_id = current_user.id AND receiver_id = user_id) OR 
       (sender_id = user_id AND receiver_id = current_user.id))
    ORDER BY created_at
  - UPDATE messages SET is_read = True WHERE sender_id = user_id AND receiver_id = current_user.id AND is_read = False
Возвращает: Список сообщений {id, sender_id, receiver_id, content, is_read, created_at, is_group, group_id}

GET /groups/{group_id}/messages
-------------------------------
Описание: Получить историю сообщений группы
Параметры: group_id
Проверка: Пользователь должен быть участником группы (GroupMember)
SQL операции:
  - SELECT * FROM group_members WHERE group_id = ? AND user_id = current_user.id
  - SELECT * FROM messages WHERE group_id = ? ORDER BY created_at
Возвращает: Список сообщений группы

================================================================================
3. ДРУЗЬЯ
================================================================================

POST /friends/add
-----------------
Описание: Отправить запрос в друзья
Параметры: FriendRequest {friend_id}
SQL операции:
  - Проверка существования: SELECT * FROM friendships WHERE 
      ((user_id = current_user.id AND friend_id = friend_id) OR 
       (user_id = friend_id AND friend_id = current_user.id))
  - INSERT INTO friendships (user_id, friend_id, status, created_at) VALUES (current_user.id, friend_id, 'pending')
WebSocket: Отправка {type: "friend_request", from_user_id, from_username} получателю

GET /friends
------------
Описание: Получить список друзей (принятые запросы)
SQL операции:
  - SELECT * FROM friendships WHERE 
      ((user_id = current_user.id OR friend_id = current_user.id) AND status = 'accepted')
  - Для каждого: SELECT * FROM users WHERE id = friend_id
Возвращает: Список друзей {id, username, is_online, status}

GET /friends/requests
---------------------
Описание: Получить входящие запросы в друзья
SQL операции:
  - SELECT * FROM friendships WHERE friend_id = current_user.id AND status = 'pending'
  - Для каждого: SELECT * FROM users WHERE id = user_id
Возвращает: Список заявок {friendship_id, user_id, username}

POST /friends/accept/{friendship_id}
-------------------------------------
Описание: Принять запрос в друзья
Параметры: friendship_id
SQL операции:
  - SELECT * FROM friendships WHERE id = friendship_id AND friend_id = current_user.id AND status = 'pending'
  - UPDATE friendships SET status = 'accepted' WHERE id = friendship_id
WebSocket: Отправка {type: "friend_accepted", friendship_id, friend_id, friend_username} инициатору

DELETE /friends/{friend_id}
---------------------------
Описание: Удалить друга
Параметры: friend_id
SQL операции:
  - SELECT * FROM friendships WHERE 
      ((user_id = current_user.id AND friend_id = friend_id) OR 
       (user_id = friend_id AND friend_id = current_user.id))
  - DELETE FROM friendships WHERE id = friendship.id
Возвращает: {message: "Friend removed"}

================================================================================
4. ГРУППЫ
================================================================================

GET /groups
-----------
Описание: Получить список групп пользователя
SQL операции:
  - SELECT * FROM group_members WHERE user_id = current_user.id
  - Для каждой группы: SELECT * FROM groups WHERE id = membership.group_id
  - COUNT(*) FROM group_members WHERE group_id = group.id
Возвращает: Список групп {id, name, creator_id, is_admin, members_count, created_at}

POST /groups/create
-------------------
Описание: Создать группу с участниками
Параметры: GroupCreate {name, members: List[str]} (логины участников)
SQL операции:
  - INSERT INTO groups (name, creator_id, created_at)
  - INSERT INTO group_members (user_id, group_id, is_admin, joined_at) для создателя (is_admin=True)
  - Для каждого логина из members:
      SELECT * FROM users WHERE username = ?
      INSERT INTO group_members (user_id, group_id, is_admin=False, joined_at)
WebSocket: Отправка {type: "group_invite", group_id, group_name, inviter} каждому участнику
Возвращает: {group_id, name}

GET /groups/{group_id}
----------------------
Описание: Получить информацию о группе
Параметры: group_id
Проверка: Пользователь должен быть участником
SQL операции:
  - SELECT * FROM group_members WHERE group_id = ? AND user_id = current_user.id
  - SELECT * FROM groups WHERE id = ?
  - COUNT(*) FROM group_members WHERE group_id = ?
Возвращает: {id, name, creator_id, is_admin, members_count, created_at}

GET /groups/{group_id}/members
-------------------------------
Описание: Получить участников группы
Параметры: group_id
Проверка: Пользователь должен быть участником
SQL операции:
  - SELECT * FROM group_members WHERE group_id = ? AND user_id = current_user.id
  - SELECT * FROM group_members WHERE group_id = ?
  - Для каждого: SELECT * FROM users WHERE id = member.user_id
Возвращает: Список участников {id, username, is_admin, is_online, status, joined_at}

POST /groups/{group_id}/members
--------------------------------
Описание: Добавить участника в группу (только для админов)
Параметры: group_id, GroupMemberAdd {user_login или user_id}
Проверка: Текущий пользователь должен быть админом
SQL операции:
  - SELECT * FROM group_members WHERE group_id = ? AND user_id = current_user.id AND is_admin = True
  - SELECT * FROM users WHERE username = ? OR id = ?
  - Проверка: SELECT * FROM group_members WHERE group_id = ? AND user_id = ?
  - INSERT INTO group_members (user_id, group_id, is_admin=False, joined_at)
WebSocket: Отправка {type: "group_invite", group_id, group_name, inviter} новому участнику

DELETE /groups/{group_id}/members/{user_id}
--------------------------------------------
Описание: Удалить участника из группы (только для админов)
Параметры: group_id, user_id
Проверка: Текущий пользователь админ, нельзя удалить создателя
SQL операции:
  - SELECT * FROM group_members WHERE group_id = ? AND user_id = current_user.id AND is_admin = True
  - SELECT * FROM groups WHERE id = ? (проверка creator_id != user_id)
  - SELECT * FROM group_members WHERE group_id = ? AND user_id = ?
  - DELETE FROM group_members WHERE id = membership.id
WebSocket: Отправка {type: "removed_from_group", group_id, group_name} удалённому участнику

POST /groups/{group_id}/leave
------------------------------
Описание: Выйти из группы
Параметры: group_id
Проверка: Создатель не может выйти
SQL операции:
  - SELECT * FROM group_members WHERE group_id = ? AND user_id = current_user.id
  - SELECT * FROM groups WHERE id = ? (проверка creator_id != current_user.id)
  - DELETE FROM group_members WHERE id = membership.id
Возвращает: {message: "Left group successfully"}

DELETE /groups/{group_id}
-------------------------
Описание: Удалить группу (только создатель)
Параметры: group_id
Проверка: Только создатель может удалить
SQL операции:
  - SELECT * FROM groups WHERE id = ? AND creator_id = current_user.id
  - DELETE FROM group_members WHERE group_id = ?
  - DELETE FROM groups WHERE id = ?
WebSocket: Рассылка {type: "group_deleted", group_id, group_name} всем участникам

================================================================================
5. ЗВОНКИ (WebRTC)
================================================================================

handle_call_initiate(call_data, initiator_id, db)
--------------------------------------------------
Описание: Обработка инициации звонка через WebSocket
Параметры:
  - call_data: {receiver_id, call_type: "audio"}
  - initiator_id: ID звонящего
  - db: SQLAlchemy сессия
SQL операции:
  - INSERT INTO calls (initiator_id, receiver_id, call_type, status, created_at) VALUES (?, ?, ?, 'pending')
  - SELECT * FROM users WHERE id = initiator_id (для получения username)
WebSocket отправка:
  - Инициатору: {type: "call_initiated", call_id, receiver_id}
  - Получателю: {type: "incoming_call", call_id, initiator_id, initiator_name, call_type, timestamp}
  - Если получатель офлайн: UPDATE calls SET status = 'offline'

handle_call_response(response_data, user_id, db)
-------------------------------------------------
Описание: Обработка ответа на звонок (Accept/Decline + SDP Answer)
Параметры:
  - response_data: {call_id, action: "accept"/"decline", sdp}
  - user_id: ID отвечающего
  - db: SQLAlchemy сессия
SQL операции:
  - SELECT * FROM calls WHERE id = call_id
  - Если decline: UPDATE calls SET status = 'declined' WHERE id = call_id
  - Если accept: UPDATE calls SET status = 'accepted', ended_at = NULL WHERE id = call_id
WebSocket отправка:
  - При decline: {type: "call_declined", call_id} инициатору
  - При accept: {type: "call_accepted", call_id, sdp} инициатору (sdp = answer от callee)

handle_ice_candidate(candidate_data, user_id, db)
--------------------------------------------------
Описание: Пересылка ICE кандидатов для WebRTC соединения
Параметры:
  - candidate_data: {call_id, candidate, target_user_id}
  - user_id: ID отправителя
  - db: SQLAlchemy сессия
SQL операции: Нет прямых операций с БД
WebSocket отправка:
  - {type: "ice_candidate", call_id, candidate, sender_id} целевому пользователю (target_user_id)

WebSocket обработка call_offer
-------------------------------
Описание: Пересылка SDP Offer от звонящего к принимающему
Параметры: {call_id, sdp}
SQL операции:
  - SELECT * FROM calls WHERE id = call_id
  - Проверка: call.initiator_id == user_id (только инициатор может отправить offer)
WebSocket отправка:
  - {type: "call_offer", call_id, sdp} получателю (call.receiver_id)

WebSocket обработка call_end
-----------------------------
Описание: Завершение звонка
Параметры: {call_id}
SQL операции:
  - SELECT * FROM calls WHERE id = call_id
  - UPDATE calls SET status = 'completed', ended_at = datetime.utcnow() WHERE id = call_id
WebSocket отправка:
  - {type: "call_end", call_id} второй стороне звонка

================================================================================
6. WEBSOCKET ОБРАБОТЧИК
================================================================================

websocket_endpoint(websocket, user_id)
--------------------------------------
Описание: Главный WebSocket обработчик для каждого пользователя
Параметры:
  - websocket: WebSocket соединение
  - user_id: ID пользователя
Хранилище:
  - user_connections[user_id] = websocket (словарь активных соединений)
  - active_connections.append(websocket) (список всех соединений)
SQL операции при подключении:
  - SELECT * FROM users WHERE id = user_id
  - UPDATE users SET is_active = True WHERE id = user_id
Обработка сообщений (message_type):
  - "message" → handle_chat_message(...)
  - "call_initiate" → handle_call_initiate(...)
  - "call_offer" → пересылка offer получателю
  - "call_response" → handle_call_response(...)
  - "ice_candidate" → handle_ice_candidate(...)
  - "call_end" → завершение звонка, уведомление второй стороны
  - "friend_request" → создание Friendship, уведомление получателя
  - "group_invite" → добавление в GroupMember, уведомление
  - "remove_from_group" → удаление из GroupMember, уведомление
  - "leave_group" → удаление GroupMember
  - "delete_group" → удаление группы и всех участников
SQL операции при отключении:
  - UPDATE users SET is_active = False WHERE id = user_id
  - Удаление из user_connections и active_connections

================================================================================
7. SQLITE БАЗА ДАННЫХ (МОДЕЛИ)
================================================================================

Таблица: users
--------------
Поля:
  - id (Integer, Primary Key)
  - username (String(50), Unique, Index)
  - hashed_password (String(255))
  - is_active (Boolean, default=True)
  - created_at (DateTime)
Методы:
  - verify_password(password) → bool
  - set_password(password) → void

Таблица: friendships
--------------------
Поля:
  - id (Integer, Primary Key)
  - user_id (Integer, ForeignKey → users.id)
  - friend_id (Integer, ForeignKey → users.id)
  - status (String(20), default='pending') → 'pending', 'accepted', 'blocked'
  - created_at (DateTime)

Таблица: messages
-----------------
Поля:
  - id (Integer, Primary Key)
  - sender_id (Integer, ForeignKey → users.id)
  - receiver_id (Integer, ForeignKey → users.id)
  - content (Text)
  - is_read (Boolean, default=False)
  - created_at (DateTime)
  - is_group (Boolean, default=False)
  - group_id (Integer, ForeignKey → groups.id, nullable)

Таблица: groups
---------------
Поля:
  - id (Integer, Primary Key)
  - name (String(100))
  - creator_id (Integer, ForeignKey → users.id)
  - created_at (DateTime)

Таблица: group_members
-----------------------
Поля:
  - id (Integer, Primary Key)
  - user_id (Integer, ForeignKey → users.id)
  - group_id (Integer, ForeignKey → groups.id)
  - is_admin (Boolean, default=False)
  - joined_at (DateTime)

Таблица: calls
--------------
Поля:
  - id (Integer, Primary Key)
  - initiator_id (Integer, ForeignKey → users.id)
  - receiver_id (Integer, ForeignKey → users.id)
  - call_type (String(20)) → 'video' или 'audio'
  - status (String(20), default='pending') → 'pending', 'accepted', 'declined', 'ended', 'completed', 'offline'
  - created_at (DateTime)
  - ended_at (DateTime, nullable)

Таблица: offline_messages
-------------------------
Поля:
  - id (Integer, Primary Key)
  - sender_id (Integer, ForeignKey → users.id)
  - receiver_id (Integer, ForeignKey → users.id)
  - content (Text)
  - created_at (DateTime)
  - delivered (Boolean, default=False)

================================================================================
8. ВСПОМОГАТЕЛЬНЫЕ ФУНКЦИИ
================================================================================

get_current_user(token, db)
----------------------------
Описание: Получение текущего пользователя из JWT токена
Параметры:
  - token: JWT токен из заголовка Authorization
  - db: SQLAlchemy сессия
Процесс:
  1. Декодирование JWT токена (jwt.decode)
  2. Извлечение username из payload
  3. SELECT * FROM users WHERE username = ?
  4. Возврат User объекта или HTTPException 401

success_response(data, message)
-------------------------------
Описание: Стандартный формат успешного ответа API
Возвращает: {"success": true, "data": data, "message": message}

create_access_token(data, expires_delta)
-----------------------------------------
Описание: Создание JWT токена
Параметры:
  - data: dict с данными (обычно {"sub": username})
  - expires_delta: timedelta или None (по умолчанию 30 минут)
Возвращает: JWT строка

verify_token(token)
-------------------
Описание: Верификация JWT токена
Параметры: token (строка)
Возвращает: TokenData(username) или HTTPException 401

================================================================================
9. ИНИЦИАЛИЗАЦИЯ БАЗЫ ДАННЫХ
================================================================================

Base.metadata.create_all(bind=engine)
--------------------------------------
Описание: Создание всех таблиц в SQLite базе данных
Вызывается: При старте приложения (в main.py)
Результат: Создаётся файл chat.db со всеми таблицами (если не существует)

================================================================================
10. CORS И MIDDLEWARE
================================================================================

CORSMiddleware
--------------
Описание: Разрешение кросс-доменных запросов
Настройки:
  - allow_origins: ["*"]
  - allow_credentials: True
  - allow_methods: ["*"]
  - allow_headers: ["*"]

================================================================================
КОНЕЦ ДОКУМЕНТА
================================================================================
